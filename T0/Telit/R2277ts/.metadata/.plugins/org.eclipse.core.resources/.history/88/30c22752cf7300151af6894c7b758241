/*
 * status.c
 *
 *  Created on: 3 AÄŸu 2015
 *      Author: admin
 */

#include "board.h"
#include "timer.h"
#include "utils.h"
#include "status.h"
#include "gps.h"
#include "messages.h"
#include <stdlib.h>
#include <string.h>

typedef enum POWER_STATE_T
{
	POWER_REMOVED_STATE,
	POWER_APPLIED_STATE
}POWER_STATE;

typedef enum SIM_STATE_T
{
	SIM_REMOVED_STATE,
	SIM_INSERTED_STATE
}SIM_STATE;

typedef enum IGN_STATE_T
{
	NOT_IGNITED_STATE,
	IGNITED_STATE
}IGN_STATE;

typedef enum SPEED_STATE_T
{
	BELOW_SPEED_LIMIT_STATE,
	ABOVE_SPEED_LIMIT_STATE,
	WAIT_SPEED_ABOVE_LIMIT_TIMEOUT_STATE
}SPEED_STATE;

typedef struct SIM_STATUS_INFO_T
{
	bool b_simInserted;
	SIM_STATE simState;
	TIMER_INFO_T sim_debounce_timer;
}SIM_STATUS_INFO;

typedef struct IGNITION_INFO_T
{
	bool b_ignited;
	IGN_STATE ignState;
	TIMER_INFO_T ign_debounce_timer;
}IGNITION_INFO;

typedef struct POWER_STATUS_INFO_T
{
	bool b_powered;
	POWER_STATE powerState;
	TIMER_INFO_T power_debounce_timer;
}POWER_STATUS_INFO;

typedef struct SPEED_LIMIT_INFO_T
{
	bool b_speedLimitExceeded;
	SPEED_STATE speedState;
	TIMER_TICK_T speedViolationStartTime;
	TIMER_TICK_T speedViolationEndTime;
	TIMER_INFO_T speed_violation_timer;
}SPEED_LIMIT_INFO;

typedef struct IDLE_INFO_T
{
	TIMER_INFO_T idle_timer;
	TIMER_INFO_T idle_secs_counter_timer;
	TIMER_TICK_T idleStartTime;
	TIMER_TICK_T idleEndTime;
	IDLE_STATES_T state;
}IDLE_INFO;

TIMER_INFO_T dummy_timer;
TIMER_INFO_T idle_time_test_timer;

SIM_STATUS_INFO sim_status_info;
IGNITION_INFO ignition_info;
POWER_STATUS_INFO power_status_info;
SPEED_LIMIT_INFO speed_limit_info;
IDLE_INFO idle_info;
STATUS_INFO_T status_info;
EVENT_INFO_T event_info;



bool CheckSIMStatus();
bool CheckIgnStatus();

void Init_SIMInfo();
void Init_IgnInfo();
void Init_PowerInfo();
void Init_IdleInfo();
void Init_SpeedLimitInfo();

#define SIM_DEBOUNCE_TIME       10
#define IGN_DEBOUNCE_TIME       10
#define POWER_DEBOUNCE_TIME     10

static void SetSimStatus(bool status);
static void SetIgnitionStatus(bool status);
static void SetPowerStatus(bool status);

static void ProcessIdleStatus();
static void ProcessSpeedLimitStatus();
static void ProcessStopTimeLimitStatus();

uint32_t u32_speedKmTest = 20;

uint32_t u32_maxSpeedLimit = 100;
uint32_t u32_maxSpeedLimitViolatonTime = 500;
uint32_t u32_idleTimeLimit = 500;
uint32_t u32_stopTimeLimit = 1000;

/***********************************************************************************/
Trio_StatusTask()
{
	//SpeedLimitTestFunction();
	//IdleTimeTestFunction();
	CheckSIMStatus();
	CheckIgnStatus();
	ProcessIdleStatus();
	ProcessSpeedLimitStatus();
	ProcessStopTimeLimitStatus();
	ProcessExtPowerStatus();
}
/**********************************************************************************/
/**
 *Handle interrupt from PININT channel 0 (sim detection interrupt)
 */
void PININT0_IRQHandler(void)
{
	uint32_t u32_riseStates;
	uint32_t u32_fallStates;

	u32_riseStates = Chip_PININT_GetRiseStates(LPC_PININT);
	u32_fallStates = Chip_PININT_GetFallStates(LPC_PININT);

	if(u32_riseStates & PININTCH0){
		Chip_PININT_ClearRiseStates(LPC_PININT, PININTCH0);
		sim_status_info.b_simInserted  = FALSE;
	}
	else if(u32_fallStates & PININTCH0){
		Chip_PININT_ClearFallStates(LPC_PININT, PININTCH0);
		sim_status_info.b_simInserted = TRUE;
	}
	Set_Timer(&(sim_status_info.sim_debounce_timer), SIM_DEBOUNCE_TIME);
	Chip_PININT_ClearIntStatus(LPC_PININT, PININTCH0);
}

/**********************************************************************************/
void Trio_ConfigureSimDetectInterrupt()
{
	/* Initialize pin interrupt */
	Chip_SYSCTL_SetPinInterrupt(0, SIM_DETECT_PIN);							/* Set pin interrupt 0 to SIMDETECT pin*/
	Chip_PININT_Init(LPC_PININT);											/* initialize pin interrupt module */
	Chip_PININT_SetPinModeEdge(LPC_PININT, PININTCH0);				        /* set pin interrupt channel 0 to be edge sensitive */
	Chip_PININT_EnableIntHigh(LPC_PININT, PININTCH0);						/* interrupt on rising edge */
	Chip_PININT_EnableIntLow(LPC_PININT, PININTCH0);	                    /* interrupt on low level */
	NVIC_EnableIRQ(PININT0_IRQn);											/* enable pin interrupt 0 */
}

/***********************************************************************************/
bool CheckSIMStatus()
{
	switch(sim_status_info.simState)
	{
		case SIM_REMOVED_STATE:
		if(sim_status_info.b_simInserted){
			if(mn_timer_expired(&(sim_status_info.sim_debounce_timer))){
				PRINT_K("@@@@.............SIM_INSERTED...........@@@@@\r\n");
				sim_status_info.simState = SIM_INSERTED_STATE;
				status_info.sim_status = TRUE;
			}
		}
		break;

		case SIM_INSERTED_STATE:
		if(!sim_status_info.b_simInserted){
			if(mn_timer_expired(&(sim_status_info.sim_debounce_timer))){
				PRINT_K("@@@@...............SIM_REMOVED...........@@@@@\r\n");
				sim_status_info.simState = SIM_REMOVED_STATE;
				status_info.sim_status = FALSE;
				event_info.event_sim_card_removed = TRUE;
			}
		}
		break;
	}
}
/************************************************************/
/* Interrupt service routine for ignition detection         */
/************************************************************/
void PININT1_IRQHandler(void)
{
	uint32_t u32_riseStates;
	uint32_t u32_fallStates;

	u32_riseStates = Chip_PININT_GetRiseStates(LPC_PININT);
	u32_fallStates = Chip_PININT_GetFallStates(LPC_PININT);

	if(u32_riseStates & PININTCH1){
		Chip_PININT_ClearRiseStates(LPC_PININT, PININTCH1);
		ignition_info.b_ignited = NOT_IGNITED_STATE;
	}
	else if(u32_fallStates & PININTCH1){
		Chip_PININT_ClearFallStates(LPC_PININT, PININTCH1);
		ignition_info.b_ignited = IGNITED_STATE;
	}

	Set_Timer(&(ignition_info.ign_debounce_timer), IGN_DEBOUNCE_TIME);
	Chip_PININT_ClearIntStatus(LPC_PININT, PININTCH1);
}
/****************************************************************/
void Trio_ConfigureIgnDetectInterrupt()
{
	/* Initialize pin interrupt */
	Chip_SYSCTL_SetPinInterrupt(1, IGN_DETECT_PIN);							/* Set pin interrupt 0 to IGNDETECT pin*/
	Chip_PININT_Init(LPC_PININT);											/* initialize pin interrupt module */
	Chip_PININT_SetPinModeEdge(LPC_PININT, PININTCH1);				        /* set pin interrupt channel 0 to be edge sensitive */
	Chip_PININT_EnableIntHigh(LPC_PININT, PININTCH1);						/* interrupt on high level */
	Chip_PININT_EnableIntLow(LPC_PININT, PININTCH1);	                    /* interrupt on low level */
	NVIC_EnableIRQ(PININT1_IRQn);											/* enable pin interrupt 0 */
}
/****************************************************************/
bool CheckIgnStatus()
{
	switch(ignition_info.ignState)
	{
		case NOT_IGNITED_STATE:
		if(ignition_info.b_ignited){
			if(mn_timer_expired(&(ignition_info.ign_debounce_timer))){
				PRINT_K("@@@@......IGNITED..........@@@@@\r\n");
				ignition_info.ignState = IGNITED_STATE;
				status_info.ignited = TRUE;
				event_info.event_ignition_status_changed = TRUE;
			}
		}
		break;

		case IGNITED_STATE:
		if(!(ignition_info.b_ignited)){
			if(mn_timer_expired(&(ignition_info.ign_debounce_timer))){
				PRINT_K("@@@@..........NOT_IGNITED.......@@@@@\r\n");
				ignition_info.ignState = NOT_IGNITED_STATE;
				status_info.ignited = FALSE;
				event_info.event_ignition_status_changed = FALSE;
			}
		}
		break;
	}
}
/***********************************************************************/
void SetRoamingStatus(bool status)
{
	//status_info.roaming = status;
}
/***********************************************************************/
bool GetRoamingStatus()
{
	return status_info.roaming;
}
/***********************************************************************/
bool Get_AlarmStatus()
{
	uint32_t *u32_alarmStatus;

	u32_alarmStatus = (uint32_t *)&event_info;

	if(*u32_alarmStatus != 0)
		return TRUE;
	else
		return FALSE;
}
/***********************************************************************/
void SetIgnitionStatus(bool status)
{
	status_info.ignited = status;
}
/***********************************************************************/
bool GetIgnitionStatus()
{
	return status_info.ignited;
}
/************************************************************************/
void ProcessIdleStatus()
{
	RMC_MESSAGE_T rmc_info;
	uint32_t u32_speedKm;

	Get_RMCInfo(&rmc_info);
	u32_speedKmTest = rmc_info.speed*1812/1000;

	if(status_info.ignited){

		switch(idle_info.state)
		{
			case IDLE_STATE:
			if(u32_speedKmTest > 0){
				idle_info.idleEndTime = mn_get_timer_tick();
				idle_info.state = NOT_IDLE_STATE;
				PRINT_K("Set State = NOT_IDLE_STATE\r\n");
			}
			break;

			case WAITING_IDLE_TIMEOUT_STATE:
			if(mn_timer_expired(&(idle_info.idle_timer))){
				event_info.event_max_idle_time_exceeded = SET;
				PRINT_K("mn_timer_expired(idle_info.idle_timer)\r\n");
				idle_info.state = IDLE_STATE;
			}
			else if(u32_speedKmTest > 0){
				idle_info.state = NOT_IDLE_STATE;
				PRINT_K("if(u32_speedKm > 0) in WAITING_IDLE_TIMEOUT_STATE\r\n");
			}
			break;

			case NOT_IDLE_STATE:
			if(u32_speedKmTest == 0){
				idle_info.idleStartTime = mn_get_timer_tick();
				Set_Timer(&(idle_info.idle_timer), u32_idleTimeLimit);
				idle_info.state = WAITING_IDLE_TIMEOUT_STATE;
				PRINT_K("Set State = WAITING_IDLE_TIMEOUT_STATE\r\n");
			}
			break;
		}
	}
}
/*************************************************************************/
void ProcessSpeedLimitStatus()
{
	RMC_MESSAGE_T rmc_info;
	uint32_t u32_speedKm;

	Get_RMCInfo(&rmc_info);

	u32_speedKm = rmc_info.speed*1812/1000;

	switch(speed_limit_info.speedState)
	{
		case BELOW_SPEED_LIMIT_STATE:
		if(u32_speedKm > u32_maxSpeedLimit){
			PRINT_K("Hiz limitinin ustune cikildi\r\n");
			Set_Timer(&(speed_limit_info.speed_violation_timer), u32_maxSpeedLimitViolatonTime);
			speed_limit_info.speedState = WAIT_SPEED_ABOVE_LIMIT_TIMEOUT_STATE;
			speed_limit_info.speedViolationStartTime = mn_get_timer_tick();
			status_info.speed_status = ABOVE_SPEED_LIMIT;
		}
		break;

		case ABOVE_SPEED_LIMIT_STATE:
		if(u32_speedKm < u32_maxSpeedLimit){
			PRINT_K("Hiz limitinin altina inildi\r\n");
			speed_limit_info.speedState = BELOW_SPEED_LIMIT_STATE;
			event_info.event_speed_limit_violation = TRUE;
			speed_limit_info.speedViolationEndTime = mn_get_timer_tick();
			status_info.speedLimitViolationDuration =
					GetTimeDifference(speed_limit_info.speedViolationStartTime,
									  speed_limit_info.speedViolationEndTime);

			status_info.speed_status = BELOW_SPEED_LIMIT;
		}
		break;

		case WAIT_SPEED_ABOVE_LIMIT_TIMEOUT_STATE:
		if(u32_speedKm > u32_maxSpeedLimit){
			if(mn_timer_expired(&(speed_limit_info.speed_violation_timer))){
				speed_limit_info.speedState = ABOVE_SPEED_LIMIT_STATE;
				event_info.event_speed_limit_violation = TRUE;
				PRINT_K("Hiz limiti timeout\r\n");
			}
		}
		else
			speed_limit_info.speedState = BELOW_SPEED_LIMIT_STATE;
		break;
	}
}
/************************************************************************/
void ProcessStopTimeLimitStatus()
{
	switch(status_info.stop_time_info.stop_status){
		case  VEHICLE_STATUS_STOPPED:
		if(status_info.ignited)
			status_info.stop_time_info.stop_status = VEHICLE_STATUS_NOT_STOPPED;
		break;

		case VEHICLE_STATUS_NOT_STOPPED:
		if(!status_info.ignited){
			status_info.stop_time_info.stop_status = WAITING_VEHICLE_STOP_TIMEOUT;
			Set_Timer(&status_info.stop_time_info.stop_timer, u32_stopTimeLimit);
		}
		break;

		case WAITING_VEHICLE_STOP_TIMEOUT:
		if(status_info.ignited)
			status_info.stop_time_info.stop_status = VEHICLE_STATUS_NOT_STOPPED;
		else if(mn_timer_expired(&status_info.stop_time_info.stop_timer)) {
			event_info.event_max_stop_time_exceeded = TRUE;
			status_info.stop_time_info.stop_status = VEHICLE_STATUS_STOPPED;
		}
		break;
	}
}
/****************************************************************/
void Trio_ConfigureExtPowerDetectInterrupt()
{
	/* Initialize pin interrupt */
	Chip_SYSCTL_SetPinInterrupt(2, POWER_DETECT_PIN);						/* Set pin interrupt 2 for ext. power detection*/
	Chip_PININT_Init(LPC_PININT);											/* initialize pin interrupt module */
	Chip_PININT_SetPinModeLevel(LPC_PININT, PININTCH2);				        /* set pin interrupt channel 2 to be edge sensitive */
	Chip_PININT_EnableIntHigh(LPC_PININT, PININTCH2);						/* interrupt on high level */
	Chip_PININT_EnableIntLow(LPC_PININT, PININTCH2);	                    /* interrupt on low level */
	NVIC_EnableIRQ(PININT2_IRQn);											/* enable pin interrupt 2 */
}
/**********************************************************************************/
/**
 *Handle interrupt from PININT channel 2 (External Power Status interrupt)
 */
void PININT2_IRQHandler(void)
{
	uint32_t u32_riseStates;

	u32_riseStates = Chip_PININT_GetRiseStates(LPC_PININT);

	if(u32_riseStates & PININTCH2){
		Chip_PININT_ClearRiseStates(LPC_PININT, PININTCH2);
		power_status_info.b_powered  = TRUE;
	}
	else{
		Chip_PININT_ClearFallStates(LPC_PININT, PININTCH2);
		power_status_info.b_powered = FALSE;
	}

	Set_Timer(&(power_status_info.power_debounce_timer), POWER_DEBOUNCE_TIME);
	Chip_PININT_ClearIntStatus(LPC_PININT, PININTCH2);
}

/************************************************************************/
void ProcessExtPowerStatus()
{
	switch(power_status_info.powerState){
		case POWER_REMOVED_STATE:
		if(power_status_info.b_powered){
			if(mn_timer_expired(&(power_status_info.power_debounce_timer))){
				PRINT_K("@@@@.............POWER_APPLIED...........@@@@@\r\n");
				power_status_info.powerState = POWER_APPLIED_STATE;
				status_info.power_status = TRUE;
			}
		}
		break;

		case POWER_APPLIED_STATE:
		if(!(power_status_info.b_powered)){
			if(mn_timer_expired(&(power_status_info.power_debounce_timer))){
				PRINT_K("@@@@...............POWER_REMOVED...........@@@@@\r\n");
				power_status_info.powerState = POWER_REMOVED_STATE;
				status_info.power_status = FALSE;
			}
		}
		break;
	}
}
/***********************************************************************/
void SetPowerStatus(bool status)
{
	status_info.power_status = status;
}
/************************************************************************/
void SetBatteryLevel(uint16_t batteryLevel)
{
	char buffer[10];
	status_info.batteryLevel = batteryLevel * 10;
	PRINT_K("Battery Voltage:");
	itoa(status_info.batteryLevel, buffer, 10);
	PRINT_K(buffer);
}
/************************************************************************/
void Get_EventInfo(EVENT_INFO_T *event_info_t)
{
	*event_info_t = event_info;
	memset(&event_info, 0, sizeof(event_info));
}
/*************************************************************************/
void Get_StatusInfo(STATUS_INFO_T *t_status)
{
	*t_status = status_info;
}
/*************************************************************************/
void Init_StatusInfo()
{
	//status_info.speed_status = BELOW_SPEED_LIMIT;
	//status_info.power_status = POWER_REMOVED;

	Init_SIMInfo();
	Init_IgnInfo();
	Init_PowerInfo();
	Init_IdleInfo();
	Init_SpeedLimitInfo();

	//status_info.idle_time_info.idle_status = VEHICLE_STATUS_IDLE;
	//status_info.idle_time_info.idle_time = 0;
	status_info.stop_time_info.stop_status = VEHICLE_STATUS_STOPPED;
	status_info.stop_time_info.stop_time = 0;
	memset(&event_info, 0, sizeof(event_info));

}
/***************************************************************************/
void Init_SIMInfo()
{
	sim_status_info.simState = SIM_REMOVED_STATE;
	sim_status_info.b_simInserted = FALSE;
}
/***************************************************************************/
void Init_IgnInfo()
{
	ignition_info.ignState = NOT_IGNITED_STATE;
	ignition_info.b_ignited = FALSE;
}
/****************************************************************************/
void Init_PowerInfo()
{
	power_status_info.powerState = POWER_REMOVED_STATE;
	power_status_info.b_powered = FALSE;
}
/****************************************************************************/
void Init_IdleInfo()
{
	idle_info.state = IDLE_STATE;
	Set_Timer(&idle_time_test_timer, 50);

}
void Init_SpeedLimitInfo()
{
	speed_limit_info.b_speedLimitExceeded = FALSE;
	speed_limit_info.speedState = BELOW_SPEED_LIMIT_STATE;
	Set_Timer(&dummy_timer, 10);
}
/***************************************************************************/
void Init_EventInfo()
{
	memset(&event_info, 0, sizeof(event_info));
}
/****************************************************************************/
TIMER_TICK_T GetTimeDifference(TIMER_TICK_T startTime, TIMER_TICK_T endTime)
{
	if(endTime >= startTime)
		return endTime - startTime;
	else
		return (0xFFFFFFFF - startTime + endTime);
}
/****************************************************************************/
void SpeedLimitTestFunction()
{
	static uint8_t speed_test_state = 1;

	switch(speed_test_state)
	{
		case 1:
		if(mn_timer_expired(&dummy_timer)){
			u32_speedKmTest++;
			if(u32_speedKmTest == 200)
				speed_test_state = 2;
			Set_Timer(&dummy_timer, 10);
		}
		break;

		case 2:
		if(mn_timer_expired(&dummy_timer)){
			u32_speedKmTest--;
			if(u32_speedKmTest == 0)
				speed_test_state = 1;
			Set_Timer(&dummy_timer, 10);
		}
		break;

	}
}
/*****************************************************************************/
void IdleTimeTestFunction()
{
	//if(mn_timer_expired(&idle_time_test_timer)){
	//	u32_speedKmTest--;
	//	if(u32_speedKmTest == 0){
	//		PRINT_K("u32_speedKmTest == 0");
		//	u32_speedKmTest =  100;
		//}
	//}
}
